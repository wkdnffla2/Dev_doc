# cookie, session, token의 차이점

# 계정 정보를 요청 Header에 넣는 방식


-   이렇게 하면 절대 안된다!!!
-   앱에서 서버로 http 요청을 할때 따로 암호화를 하지 않으므로 해커가 http 요청을 가로채(intercept)서 사용자의 계정 정보를 알수 있다.

#   Session / Cookie 방식

-   Session / Cookie 방식 인증은 기본적으로 세션 저장소를 필요로 한다
-   세션 저장소는 로그인시 사용자 정보를 저장하고 열쇠로 사용할 수 있는 세션ID를 만든다. 그리고 그걸 HTTP 헤더에 실어 클라이언트에 보낸다.
-   브라우저는 세션 ID를 포함하는 쿠키를 저장하고 있다.
- 인증이 필요한 요청에 해당 쿠키를 끼워 서버에 request를 보낸다. 

##  인증 절차

    1. 사용자가 로그인
    2. 서버에서는 계정 정보를 읽어 사용자를 확인후 사용자의 고유 id 값을 부여한 후 세션 장소에 저장하고 이와 연결되는 세션 ID를 발행한다.
    3. 클라이언트는 서버에서 해당 세션 id 를 받아 쿠키에 저장 한 후 인증이 필요한 요청마다 쿠키를 헤더에 끼워 보낸다,.
    4. 서버에는 쿠키를 받아 세션 저장소에서 확인후, 일치하는 정보를 가져온다.
    5. 인증이 완료되고 서버는 사용자에 맞는 데이터를 보내준다.

# session 과 cookie의 차이점
    session : 서버에서 가지고 있는 정보
    cookie : 서버에서 발급된 세션을 열기 위한 키 값(세션 ID 라고함)
    쿠키만으로 인증을 한다는 것은 서버의 자원을 사용하지 않는것.
    클라이언트가 인증 정보를 책임지는 것을 의미한다.
    
    쿠키만으로 인증을 할 경우, 해커가 http 요청을 중간에서 뺏어갈때 모든 정보가 탈취된다.
    쿠키는 조작된 데이터 일수 있으므로 실제 정보가 존재하는 database 를 사용해서 작업합니다.
    따라서 보안과는 관련 없는 장바구니, 자동 로그인 설정 같은 경우에 유용하게 사용한다.

    인증의 책임을 서버가 지게 하기 위해서 세션을 함께 사용한다.
    사용자는 쿠키를 이용하고 서버에서는 쿠키를 받아 세션의 정보를 접근하는 방식으로 인증 한다.

# 장단점

    -장점
    쿠키가 담긴 http 요청이 도중에 노출 되더라도 쿠키 자체(세션 id)는 유의미한 값을 갖고 있지 않다.
    중요한 정보는 서버 세션에만 있다
    고유의 ID 값을 발급받는다.
    쿠키 값을 받았을 때 일일이 회원정보를 확인할 필요없이 바로 어떤 회원인지 확인이 가능하다..?
    -단점
    세선 하이재킹 공격이 가능할 수 있다.
    해결책은 https를 사용해 요청 자체를 탈취해도 안의 정보를 읽기 힘들게 하거나 세션에 유효시간을 부여할 수 있다.
    서버에서 추가적인 저장공간이 필요하다
    서버에서 세션 저장소를 사용하므로 부하가 높아진다.

# token 기반 인증 방식

- jwt(json web token)는 인증에 필요한 정보들을 암호화 시킨 토큰을 의미합니다.
-   위의 세션/쿠키 방식과 유사하게 사용자는 access token(JWT token)을 http 헤더에 실어 서버에 전송한다.
-   토큰은 임의로 생성된 비밀번호 같이 동작한다.
-   제한된 수명을 가지고 새로운 토큰은 한번 만료되면 새로 생성되어야 한다.
-   일반적으로jwt 뿐 아니라 openID connect 프로토콜도 사용이 가능하다.

# JWT Token

    Header :: Header, Payload, Verify Signature 를 암호화할 방식(alg), 타입(Type) 등을 포함합니다.
    Payload :: 서버에서 보낼 데이터 - 일반적으로 user의 id, 유효기간 포함
    Verify Signature :: Base64 방식으로 인코딩한 Header, Payload, Secret key 를 더한 후 서명됩니다.

    결과 :: Encoded Header + "." + Encoded Payload + "." + Verify Signature

    Header, Payload 는 암호화 되지 않으므로, 디코딩하여 확인할 수 있습니다. 그러므로 Payload 에 유저의 중요한 정보(비밀번호 등) 가 들어가면 쉽게 노출될 수 있습니다.

#   인증절차

    사용자가 로그인을 합니다.
    서버에서는 계정 정보를 읽어 사용자를 확인 후, 사용자의 고유 ID 값을 부여한 후 기타 정보와 함께 Payload 에 집어넣습니다.
    JWT 토큰의 유효기간을 설정합니다.
    암호화할 Secret key 를 이용해 Access Token 을 발급합니다.
    사용자는 Access Token 을 받아 저장 후, 인증이 필요한 요청마다 토큰을 헤더에 실어 보냅니다.
    서버에서는 해당 토큰의 Verify Signature 를 Secret key 로 복호화한 후, 조작 여부, 유효기간을 확인합니다.
    검증이 완료되었을 경우, Payload 를 디코딩 하여 사용자의 ID 에 맞는 데이터를 가져옵니다.

    세션 / 쿠키 방식과 가장 큰 차이점은 세션 / 쿠키는 세션 저장소에 유저 정보를 넣는 반면, JWT 는 토큰 안에 유저의 정보들이 넣어진다는 점 입니다. 클라이언트 입장에서는 HTTP 헤더에 세션 ID 나 토큰을 실어서 보내준다는 점에선 동일하지만, 서버 측에서는 인증을 위해 암호화를 한다 vs 별도의 저장소를 이용한다 의 차이가 발생합니다.

# 장단점

    장점
    1 간편
    세션/쿠키 인증은 별도의 저장소 관리가 필요합니다.
    JWT 는 발급한 후 검증만 하기 때문에 추가 저장소가 필요하지 않습니다. (StateLess - 상태/정보 저장하지 않음) 이는 서버를 확장하거나 유지, 보수하는데 유리합니다.

    2 확장성이 뛰어남
    토큰 기반으로 하는 다른 인증 시스템에 접근이 가능합니다.
    Facebook, Google, Microsoft 로그인 등은 모두 토큰 기반으로 인증을 하는데, 권한을 받을 수도, 프로필을 써드파티 웹사이트에 제공하도록 허가 할 수도 있습니다.

    단점
    1. 이미 발급된 JWT 에 대해서는 유효기간이 완료될 때 까지는 계속 사용이 가능합니다.
    이에 대한 해결책은, Access Token 유효기간을 짧게 하고 Refresh Token 이라는 새로운 토큰을 발급합니다. 그렇게 되면 Access Token 을 탈취당해도 상대적으로 피해를 줄일 수 있습니다.

    2. Payload 정보가 제한적입니다.
    Payload 는 따로 암호화되지 않기 때문에 디코딩하면 누구나 정보를 확인할 수 있습니다. 따라서 유저의 중요한 정보들은 Payload 에 넣을 수 없습니다.

    3. JWT의 길이
    JWT 의 길이는 길기 때문에 인증이 필요한 요청이 많아질수록 서버의 자원낭비가 발생합니다.
