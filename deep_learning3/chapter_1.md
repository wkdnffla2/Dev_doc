#   제 1고지 미분 자동 계산

#   1. 상자로서의 변수

##  1.1 변수란

    상자에 데이터를 넣을때 상자를 변수라고 한다.

## 1.2 Variable 클래스 구현

    DeZero에서 사용하는 변수라는 개념을 Variable 이라는 이름의 클래스로 구현

    상자 안에 넣는 데이터로는 넘파이의 다차원 배열을 사용
    머신러닝 시스템은 기본 데이터 구조로 다차원 배열을 사용하기 때문에 Dezero의 Variable 클래스는 넘파이의 다차원 배열만 취급한다.
    이 책에서는 앞으로 numpy.ndarray 인스턴스를 단순히 ndarray 인스턴스라고 부른다.

## 1.3. 넘파이의 다차원 배열

    다차원 배열에서 원소에서 순서에는 방향이 있고 이 방향을 차원 혹은 축 이라고 한다.

![그림1-2](./img/그림%201-2.png)
    
    넘파이의 ndarray 인스턴스에는 ndim 이라는 인스턴스 변수가 있습니다.
    ndim은 number of dimenstions의 약자이다.

#   2. 변수를 낳는 함수

    
##  2.1 함수란

    함수는 입력한 변수를 다를 변수로의 대응 관계를 정한 것 이다.

![그림2-1](./img/그림%202-1.png)

##  2.2 Function 클래스 구현

    Function 클래스는 Variable 인스턴스를 입력받아 variable 인스턴스를 출력
    variable 인스턴스의 실제 데이터는 인스턴스 변수인 data에 있다.

## 2.3 Function 클래스 이용

    앞으로는 다양한 함수가 필요하다ㅡㄴ 점을 고려하면 Function 클래스는 기반 클래스로 두고 DeZero의 모든 함수가 공통적으로 제공하는 기능만 담아두는 것이 좋을거 같다.


#   3. 함수연결

    DeZero의 변수와 함수를 만들었다. 2단계에서 Square라는 제곱계산용 함수 클래스를 구현했다.

    이장에서는 다른 함수를 구현하고 여러 함수를 조합해 계산한다.

# 3.1 exp 함수 구현

    함수를 구현했다!

# 3.2 함수 연결

    DeZero 함수들을 연이어 사용이 가능하다.    

![그림3-1](./img/그림%203-1.png)


#   4.수치미분

    지금까지 Variable 클래스와 Function 클래스를 구현했다.
    미분을 자동으로 계산하기 위해서!
    수치 미분을 간단한 방법으로 계산해 본다.

##  4.1 미분이란

    미분은 간단히 말하면 변화율이다.

![식4-1](./img/식%204.1.png)
![그림4-1](./img/그림%204-1.png)

    h값을 한없이 0에 가깝게 줄여 x 의 변화 비율을 구하면 그게 미분 값이다.

## 4.2 수치 미분 구현

    컴퓨터는 극한을 취급할 수 없으니 h를 극한과 비슷한 값으로 대체한다.
    매우 작은값을 이용하여 미분 하는 것을 수치 미분이라고 한다.
    이에 오차가 생길수 밖에 없는데 이 근사 오차를 줄이는 방법으로 중앙 차분이 있다.
    중앙 차분은 f(x-h) 와 f(x+h)의 차이를 구한다.

![그림4-2](./img/그림%204-2.png)

    x 와 x+h 사이에서 기울기를 구하는 방법은 전진 차분 이라고 한다.
    중앙 차분 쪽이 오차가 작다.
    중앙 차분을 구현하는 함수를 numerical_diff(f, x, eps=1e-4)로 구현한다.
    f는 미분대상의 함수이며 Function 인스턴스 이다. 두번째 인수 x는 미분을 계산하는 변수, eps는 작은값을 나타낸다.

## 4.3 합성 함수의 미분

    코드로 작성했다.

## 4.4 수치 미분의 문제점

    수치 미분의 결과에는 오차가 포함되어있다. 계산에 따라 커질수도 있다.
    수치 미분의 문제는 계산량이 많다는 점이다. 따라서 역전파가 등장한다.
    역전파를 정확하게 구현했는지 확인하기 위해 수치미분 값을 이용한다. 이를 기울기 확인 gradient checking 이라고 한다.

# 5. 역전파 이론

    수치미분은 계산 비용과 정확도면에서 문제가 있다
    역전파가 구세주로 등장할 시점.
    역전파를 이용하면 미분을 효율적으로 계산 할 수있고 결괏값의 오차도 더 작다.

## 5.1 연쇄 법칙

    역전파를 이해하는 열쇠는 연쇄법칙 이다.
    합성 함수의 미분은 구성함수 각각을 미분한후 곱한것과 같다.

![그림5-1](./img/그림%205-1.png)

    x에 대한 y의 미분은 다음과 같다.

![식5-1](./img/식%205.1.png)

    각각 함수의 미분값을 모두 곱한것과 같다!

## 5.2 역전파 원리 도출

![식5-3](./img/식%205.3.png)
![그림5-2](./img/그림%205-2.png)
![그림5-3](./img/그림%205-3.png)
![그림5-4](./img/그림%205-4.png)

    y의 입력값에 대한 미분값이 전파된다!
    머신러닝은 주로 대량의 매개변수를 입력받아서 마지막에 손실함수를 거쳐 출력을 내는 형태로 진행
    손실 함수의 각 매개변수에 대한 미분을 졔산해야된다.

## 5.3 계산 그래프로 살펴보기

![그림5-5](./img/그림%205-5.png)

    역전파 시에는 순전파일때 사용한 데이터가 필요하다.
    따라서 순전파를 하고 앞의 데이터값들을 기억해야한다.

# 6. 수동 역전파

    Variable 과 Function 클래스를 확장하여 역전파를 이용한 미분을 구현

##   6.1 Variable 클래스 추가 구현

    미분 값을 저장하도록 구현

##  6.2 Function 클래스 추가 구현

    미분을 계산하는 역전파 backward 메서드 구현
    forward 메서드 호출 시 건네받은 Variable 인스턴스 유지

## 6.3 Square 와 Exp 클래스 추가 구현
    
    제곱과 exp를 계산할 클래스를 추가로 구현한다.

## 6.4 역전파 구현

![그림6-1](./img/그림%206-1.png)

    순전파를 보내고 역전파로 y를 미분한다.

![그림6-2](./img/그림%206-2.png)


# 7. 역전파 자동화

    이전 단계에서는 수동으로 조합해야 했다.
    이번 단계에서는 자동으로 시켜본다.

![그림7-1](./img/그림%207-1.png)

    일반적인 순전파를 한번만 하면 자동으로 역전파가 되게 만든다!

##  7.1 역전파 자동화의 시작

    함수 입장에서는 변수는 입력과 출력에 쓰인다
    변수 입장에서는 함수에 의해 만들어 진다.
![그림7-2](./img/그림%207-2.png)

    assert 부분에서 에러가 발생하는데 예제 코드를 그대로 가져다 쓰면 작동함 왜..?

![그림7-3](./img/그림%207-3.png)

    이렇게 보면 링크드 리스트 형태를 띄운다.

## 7.2 역전파 도전!

    단계별로 코드 구현!

    함수를 가져오고 함수의 입력을 가져온다 함수의 backward 메서드를 호출한다.

