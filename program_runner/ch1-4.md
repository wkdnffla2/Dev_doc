# 1.4 매크로 함수

    예전의 C에서는 짧은 연산을 할 때 합ㅁ수 대신 매크로를 주로 사용
    매크로 사용 이유는 함수 호출때 발생하는 오버헤드를 매크로를 사용하면 줄일수 있다 생각했기 때문 -> 오늘날엔 무의미 (득보다 실이 크다.)

## 매크로 함수를 멀리하라

    C++에는 인라인 함수가 있어 매크로 함수가 필요 없다.
    인라인 함수 : 기존 함수를 호출하게되면 호출할 때마다 오버헤드 비용이 발생하게되는데 인라인을 사용할 경우 컴파일 단계에서 코드형태로 함수를 불러와 오버헤드 비용을 줄인다.
    자바는 매크로 함수가 없다.

---

    매크로 함수의 문제점은 매개변수가 여러번 나올때 여러번 연산이 된다는 점이다!

```c
#include<stdio.h>

#define isupper(c) ((c) >= 'A' && (c)<= 'Z') ? 1:0

int main() {
	char c;
	while (isupper(c = getchar())) 
	{
		printf("%c ", c);
	}

	return 0;
}
//ABCDEFGHIJKLMNOP
//B D F H J L N P
```
    위의 코드처럼 A이상의 글자를 입력할때 처음 입력한 글자는 무시된채 그 다음 글자를 입력 받아 Z 아래인지를 판단한다.
    C 의 표준에서는 그러지 않지만 여튼 위의 매크로함수는 구현을 잘못한것!

    ** 라이브러리 있으면 쓰자**

아래의 코드처럼 분리하는 편이 명료하게 파악이 가능하다.

```C
while ((c = getchar()) != EOF && isupper(c))
```

    다음과 같이 에러는 나지 않지만 성능의 문제가 생기는 경우도 있다.

```C
#define ROUND_TO_INT(x)  ((int)  ((x) + (((x) > 0 )? 0.5 : -0.5)))

size = ROUND_TO_INT(sqrt(dx*dx) + (dy * dy));
```

    위의 코드에서는 매크로 함수에서 x 가 2번 쓰였기 때문에 sqrt 함수가 2번 사용된다.
    따라서 함수로 만드는것이 효율성이 좋다.

## 매크로 전체와 각 인자를 괄호로 묶어라

    매크로는 코드를 치환하는 식으로 동작한다

    예를들어 1/square(x)를 실행하면 1/(x*x) 로 실행될것이다.
    하지만 매크로를 사용하면 1/x*x 가된다.
```C
#define square(x) (x) * (x)
```
    따라서 다음과 같이 사용해야한다.
```C
#define square(x) ((x) * (x))
```

    그러면 다음 코드의 문제점을 찾아보자

```C
#define ISDIGIT(c) ((c>='0') && (c<='9')) ? 1: 0
```

```C
#include <stdio.h>

#define ISDIGIT(c) ((c>='0') && (c<='9')) ? 1 : 0
int main()
{
    //printf("Hello World");
    printf("%d\n",ISDIGIT('1')*3);
    printf("%d\n",(('1'>='0') && ('1'<='9')) ? 1 : 0 * 3);
    int temp = ISDIGIT('1');
    
    printf("%d",3*temp);
    return 0;
}

```

    위의 코드로 알수 있듯이 첫번째로는 c 가 2번 사용된다는점 두번째로는 괄호로 묶이지 않아 2번째 printf문 처럼 된다는 것이다.